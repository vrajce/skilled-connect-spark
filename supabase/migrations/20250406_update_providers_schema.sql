-- Drop existing table and its dependencies
DROP TABLE IF EXISTS provider_services;
DROP TABLE IF EXISTS providers;

-- Create providers table with all fields
CREATE TABLE providers (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    business_name text NOT NULL,
    category text NOT NULL,
    description text,
    experience integer DEFAULT 0,
    location text,
    languages text[] DEFAULT '{}',
    profile_picture text,
    certifications jsonb DEFAULT '[]'::jsonb,
    faq jsonb DEFAULT '[]'::jsonb,
    status text DEFAULT 'pending',
    rating decimal(3,2) DEFAULT 0.0,
    total_bookings integer DEFAULT 0,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT valid_status CHECK (status IN ('pending', 'approved', 'rejected')),
    CONSTRAINT valid_rating CHECK (rating >= 0 AND rating <= 5)
);

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_providers_updated_at
    BEFORE UPDATE ON providers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create index for faster queries
CREATE INDEX idx_providers_user_id ON providers(user_id);
CREATE INDEX idx_providers_category ON providers(category);
CREATE INDEX idx_providers_status ON providers(status);

-- Enable RLS
ALTER TABLE providers ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Enable read access for all users"
ON providers FOR SELECT
USING (true);

CREATE POLICY "Enable insert for authenticated users only"
ON providers FOR INSERT
TO authenticated
WITH CHECK (
    auth.uid() = user_id AND
    (
        SELECT COUNT(*)
        FROM providers
        WHERE user_id = auth.uid()
    ) = 0
);

CREATE POLICY "Enable update for users based on user_id"
ON providers FOR UPDATE
TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Enable delete for users based on user_id"
ON providers FOR DELETE
TO authenticated
USING (auth.uid() = user_id);

-- Grant permissions
GRANT ALL ON providers TO authenticated;
GRANT USAGE ON SEQUENCE providers_id_seq TO authenticated;

-- Create provider_services table
CREATE TABLE provider_services (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    provider_id bigint REFERENCES providers(id) ON DELETE CASCADE,
    title text NOT NULL,
    description text,
    price decimal(10,2) NOT NULL,
    duration text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create trigger for provider_services
CREATE TRIGGER update_provider_services_updated_at
    BEFORE UPDATE ON provider_services
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Enable RLS on services
ALTER TABLE provider_services ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for services
CREATE POLICY "Enable read access for all users"
ON provider_services FOR SELECT
USING (true);

CREATE POLICY "Enable insert/update/delete for provider owners"
ON provider_services FOR ALL
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM providers
        WHERE providers.id = provider_services.provider_id
        AND providers.user_id = auth.uid()
    )
);

-- Grant permissions for services
GRANT ALL ON provider_services TO authenticated;
GRANT USAGE ON SEQUENCE provider_services_id_seq TO authenticated;
